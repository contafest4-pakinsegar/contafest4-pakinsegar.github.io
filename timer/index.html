<!doctype html>
<html lang="en" class="h-full">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Timer & Stopwatch</title>
    <link rel="icon" href="../favicon.ico">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/css/all.min.css" integrity="sha512-2SwdPD6INVrV/lHTZbO2nodKhrnDdJK9/kg2XD1r9uGqPo1cUbujc+IYdlYdEErWNu69gVcYgdxlmVmzTWnetw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.1/js/all.min.js" integrity="sha512-6BTOlkauINO65nLhXhthZMtepgJSghyimIalb+crKRPhvhmsCdnIuGcVbR5/aQY2A+260iC1OPy1oCdB6pSSwQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <!-- Prevent flash of wrong theme -->
    <script>
      (() => {
        const saved = localStorage.getItem('theme');
        const sysDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        document.documentElement.classList.toggle('dark', saved === 'dark' || (!saved && sysDark));
      })();
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- Tailwind theme and custom utilities -->
    <style type="text/tailwindcss">
      /* Make dark: respond to the .dark class (manual toggle) */
      @custom-variant dark (&:where(.dark, .dark *));
      @theme {
        --color-brand: #6366f1; /* indigo-500 */
        --color-brand-600: #4f46e5;
        --color-canvas: #0b1020;   /* page background (dark) */
        --color-surface: #111827;  /* card surface (dark) */
        --color-surface-2: #1f2937;/* alt surface (dark) */
      }
      @layer utilities {
        .btn {
          @apply inline-flex items-center gap-2 rounded-full px-4 py-2 font-medium text-sm transition
                 bg-gray-100 hover:bg-gray-200 dark:bg-gray-800 dark:hover:bg-gray-700;
        }
        .btn-brand {
          @apply bg-brand text-white hover:bg-brand-600 dark:bg-brand dark:hover:bg-brand-600;
        }
        .btn-ghost {
          @apply bg-transparent hover:bg-gray-100 dark:hover:bg-gray-800;
        }
        .chip {
          @apply rounded-full px-3 py-1 text-xs font-medium bg-gray-100 dark:bg-gray-800;
        }
        .active-tab {
          @apply bg-brand text-white shadow dark:bg-brand;
        }
        .time-shadow {
          text-shadow: 0 6px 24px rgba(99, 102, 241, 0.35);
        }
        .glass {
          @apply bg-white/70 dark:bg-black/30 backdrop-blur supports-[backdrop-filter]:backdrop-blur;
        }
        /* smooth fade slide */
        .fade-slide-enter { @apply opacity-0 -translate-y-2; }
        .fade-slide-enter-active { @apply opacity-100 translate-y-0 transition-all duration-300; }
        .fade-slide-exit { @apply opacity-100 translate-y-0; }
        .fade-slide-exit-active { @apply opacity-0 -translate-y-2 transition-all duration-300; }
      }
    </style>
    <!-- Minimal custom CSS for animations -->
    <style>
      @keyframes popInOut {
        0% { transform: scale(0.7); opacity: 0; filter: blur(4px); }
        12% { transform: scale(1.05); opacity: 1; filter: blur(0); }
        40% { transform: scale(1); }
        100% { transform: scale(0.96); opacity: 0; filter: blur(2px); }
      }
      .countdown-pop { animation: popInOut 1.1s cubic-bezier(.19,1,.22,1) forwards; }
      @keyframes ringPulse {
        0% { box-shadow: 0 0 0 0 rgba(99,102,241,.55); }
        70% { box-shadow: 0 0 0 28px rgba(99,102,241,0); }
        100% { box-shadow: 0 0 0 0 rgba(99,102,241,0); }
      }
      .ring-pulse { animation: ringPulse 1.4s ease-out 1; }
      @keyframes subtlePulse {
        0% { background-color: transparent; }
        50% { background-color: rgba(99, 102, 241, .08); }
        100% { background-color: transparent; }
      }
      .subtle-pulse { animation: subtlePulse 600ms ease-out 1; }
      @keyframes finalCountdown {
        0% { transform: scale(0.7); opacity: 0; }
        15% { transform: scale(1.2); opacity: 1; }
        100% { transform: scale(1); opacity: 1; }
      }

      .final-countdown { animation: finalCountdown 0.3s cubic-bezier(.19,1,.22,1) forwards; }
            .final-countdown { animation: finalCountdown 1s cubic-bezier(.19,1,.22,1) forwards; }
            .no-scrollbar::-webkit-scrollbar { display: none; }
            .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

      #finalCountdownNumber {
        font-size: clamp(4rem, 30vmin, 40vmin);
        word-break: break-word;
        padding: 0 1rem;
      }

      .fullscreen-timer-mode #navbar,
      .fullscreen-timer-mode #timerDisplayContainer > div:first-child,
      .fullscreen-timer-mode #timerDisplayContainer > div:last-child,
      .fullscreen-timer-mode #timerDisplayContainer > div:nth-child(3),
      .fullscreen-timer-mode main > div > div > div:last-child {
        display: none !important;
      }

      .fullscreen-timer-mode #timerSection > div > div:last-child {
        display: none !important;
      }

      .fullscreen-timer-mode #timerDisplayContainer > div:nth-child(2) {
        display: flex !important;
        align-items: center;
        gap: clamp(0.5rem, 2vw, 3rem);
      }

      .fullscreen-timer-mode #timerDisplayContainer > div:nth-child(2) > span.font-mono {
        font-size: clamp(6rem, 20vw, 30rem) !important;
        line-height: 1;
      }

      .fullscreen-timer-mode #timerDisplayContainer {
        background: transparent !important;
        border: none !important;
        box-shadow: none !important;
        padding: 0 !important;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
      }

      .fullscreen-timer-mode main {
        padding: 0 !important;
        display: flex;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
      }

      .fullscreen-timer-mode #timerSection {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .fullscreen-timer-mode .editable-time {
        font-size: clamp(6rem, 20vw, 30rem) !important;
      }
    </style>
  </head>
  <body class="h-full bg-gray-50 dark:bg-canvas text-gray-900 dark:text-gray-100 selection:bg-brand/30">
    <div id="app" class="min-h-dvh relative">
      <!-- Announcer Overlay for animated messages -->
      <div id="announceOverlay" class="pointer-events-none fixed inset-0 flex items-center justify-center z-[60] hidden">
        <div id="announceBubble" class="text-center">
          <div class="text-[14vw] leading-none font-extrabold tracking-tight text-brand drop-shadow-2xl time-shadow"></div>
          <div class="mt-3 text-xl opacity-90"></div>
        </div>
      </div>
      <!-- Final Countdown Overlay (10-0) -->
      <div id="finalCountdownOverlay" class="pointer-events-none fixed inset-0 flex items-center justify-center z-[65] hidden bg-black/40 dark:bg-black/60 backdrop-blur-sm">
        <div id="finalCountdownNumber" class="text-[40vmin] leading-none font-black tracking-tighter text-white drop-shadow-2xl"></div>
      </div>
      <!-- Top hover area to reveal navbar in fullscreen -->
      <div id="fsHoverArea" class="fixed inset-x-0 top-0 h-6 z-[49] hidden md:block"></div>
      <!-- Navbar -->
      <header id="navbar" class="fixed top-0 inset-x-0 z-50 transition-all duration-300">
        <div class="mx-auto max-w-5xl px-3 sm:px-6">
          <div class="mt-3 sm:mt-4 rounded-2xl glass border border-black/5 dark:border-white/10">
            <div class="flex items-center justify-between px-3 sm:px-4 py-2">
              <div class="flex items-center gap-2 sm:gap-3">
                <div class="hidden sm:flex items-center gap-2">
                  <!--<span class="text-xl">⏳</span>-->
                  <span class="font-semibold">Timer & Stopwatch</span>
                </div>
                <nav class="flex items-center gap-1 sm:gap-2" role="tablist" aria-label="Mode">
                  <button id="tabTimer" class="btn btn-ghost" role="tab" aria-selected="true">⏲️</button>
                  <button id="tabStopwatch" class="btn btn-ghost" role="tab" aria-selected="false">⏱️</button>
                </nav>
              </div>
              <div class="flex items-center gap-1 sm:gap-2">
                <button id="fullscreenBtn" class="btn btn-ghost" title="Toggle Fullscreen" aria-label="Toggle Fullscreen"><i class="fa-solid fa-expand"></i></button>
                <button id="themeBtn" class="btn btn-ghost" title="Toggle Theme" aria-label="Toggle Theme"><i class="fa-solid fa-moon" style="color: #B197FC;"></i></button>
              </div>
            </div>
          </div>
        </div>
      </header>
      <!-- Small floating toggle in fullscreen -->
      <button id="peekNavBtn" class="hidden fixed top-1.5 left-1/2 -translate-x-1/2 z-[51] text-xs chip opacity-80 hover:opacity-100">
        Show Controls
      </button>
      <!-- Main -->
      <main class="pt-24 sm:pt-28 pb-16">
        <div class="mx-auto max-w-5xl px-4 sm:px-6">
          <!-- Timer -->
          <section id="timerSection" class="transition-all">
            <div class="flex flex-col items-center gap-6 sm:gap-8">
              <div id="timerDisplayContainer" class="w-full rounded-3xl p-5 sm:p-7 text-center bg-white dark:bg-surface border border-black/5 dark:border-white/10 shadow-sm">
                <div class="text-xs uppercase tracking-widest opacity-60 mb-3 sm:mb-4">
                  Timer
                </div>
                <div class="flex items-end justify-center gap-2 sm:gap-3 select-none">
                  <div class="flex items-center">
                    <span data-unit="hours" class="editable-time font-mono font-bold leading-none text-[15vw] sm:text-[10vw] md:text-[8vw] lg:text-7xl px-2 rounded-md hover:bg-black/5 dark:hover:bg-white/5 focus:outline-none" contenteditable="false" role="spinbutton" aria-label="Hours" aria-valuemin="0" aria-live="polite">00</span>
                  </div>
                  <span class="font-mono font-bold text-[15vw] sm:text-[10vw] md:text-[8vw] lg:text-7xl opacity-70">:</span>
                  <div class="flex items-center">
                    <span data-unit="minutes" class="editable-time font-mono font-bold leading-none text-[15vw] sm:text-[10vw] md:text-[8vw] lg:text-7xl px-2 rounded-md hover:bg-black/5 dark:hover:bg-white/5 focus:outline-none" contenteditable="false" role="spinbutton" aria-label="Minutes" aria-valuemin="0" aria-valuemax="59" aria-live="polite">05</span>
                  </div>
                  <span class="font-mono font-bold text-[15vw] sm:text-[10vw] md:text-[8vw] lg:text-7xl opacity-70">:</span>
                  <div class="flex items-center">
                    <span data-unit="seconds" class="editable-time font-mono font-bold leading-none text-[15vw] sm:text-[10vw] md:text-[8vw] lg:text-7xl px-2 rounded-md hover:bg-black/5 dark:hover:bg-white/5 focus:outline-none" contenteditable="false" role="spinbutton" aria-label="Seconds" aria-valuemin="0" aria-valuemax="59" aria-live="polite">00</span>
                  </div>
                </div>
                <div class="mt-4 sm:mt-6 flex flex-wrap items-center justify-center gap-2">
                  <button id="timerEditBtn" class="btn">Edit</button>
                  <button id="timerStartBtn" class="btn btn-brand">Start</button>
                  <button id="timerPauseBtn" class="btn hidden">Pause</button>
                  <button id="timerResumeBtn" class="btn hidden">Resume</button>
                  <button id="timerResetBtn" class="btn hidden">Reset</button>
                </div>
                <div class="mt-3 text-xs opacity-70">
                  Tip: Click "Edit" or tap segments (HH, MM, SS) to set time. Use <kbd><i class="fa-solid fa-arrow-up"></i></kbd>/<kbd><i class="fa-solid fa-arrow-down"></i></kbd> to adjust.
                </div>
              </div>
              <!-- Presets -->
              <div class="flex flex-wrap items-center justify-center gap-2">
                <button class="chip hover:bg-brand/10 hover:text-brand" data-preset="300000">+5 min</button>
                <button class="chip hover:bg-brand/10 hover:text-brand" data-preset="600000">+10 min</button>
                <button class="chip hover:bg-brand/10 hover:text-brand" data-preset="900000">+15 min</button>
                <button class="chip hover:bg-brand/10 hover:text-brand" data-preset="1800000">+30 min</button>
                <button class="chip hover:bg-brand/10 hover:text-brand" data-preset="60000">+1 min</button>
                <button class="chip hover:bg-brand/10 hover:text-brand" data-preset="10000">+10 sec</button>
              </div>
            </div>
          </section>
          <!-- Stopwatch -->
          <section id="stopwatchSection" class="hidden transition-all">
            <div class="flex flex-col items-center gap-6 sm:gap-8">
              <div class="w-full rounded-3xl p-5 sm:p-7 text-center bg-white dark:bg-surface border border-black/5 dark:border-white/10 shadow-sm">
                <div class="text-xs uppercase tracking-widest opacity-60 mb-3 sm:mb-4">
                  Stopwatch
                </div>
                <div id="swDisplay" class="font-mono font-extrabold leading-none text-[13vw] sm:text-[9vw] md:text-[7vw] lg:text-7xl time-shadow">
                  00:00:00.000
                </div>
                <div class="mt-4 sm:mt-6 flex flex-wrap items-center justify-center gap-2">
                  <button id="swStartBtn" class="btn btn-brand">Start</button>
                  <button id="swPauseBtn" class="btn hidden">Pause</button>
                  <button id="swResumeBtn" class="btn hidden">Resume</button>
                  <button id="swLapBtn" class="btn hidden">Lap</button>
                  <button id="swResetBtn" class="btn hidden">Reset</button>
                </div>
              </div>
              <!-- Laps -->
              <div class="w-full rounded-3xl px-5 sm:px-7 py-5 bg-white dark:bg-surface border border-black/5 dark:border-white/10 shadow-sm">
                <div class="flex items-center justify-between">
                  <div class="text-sm font-semibold opacity-80">Laps</div>
                  <div class="text-xs opacity-60">Click a lap to copy</div>
                </div>
                <div id="lapsList" class="mt-3 max-h-[40vh] overflow-auto no-scrollbar divide-y divide-gray-200/60 dark:divide-white/10"></div>
                <div id="lapsEmpty" class="mt-3 text-sm opacity-60">No laps yet.</div>
              </div>
            </div>
          </section>
        </div>
      </main>
      <!-- Finish audio -->
      <audio id="finishAudio" preload="auto">
        <source src="../assets/finish.mp3" type="audio/mpeg" />
      </audio>
    </div>
    <script>
      // Helpers
      const $ = (sel, ctx = document) => ctx.querySelector(sel);
      const $$ = (sel, ctx = document) => Array.from(ctx.querySelectorAll(sel));
      const pad2 = (n) => String(n).padStart(2, '0');
      const pad3 = (n) => String(n).padStart(3, '0');
      // Theme
      const themeBtn = $('#themeBtn');
      function applyTheme(theme) {
        const root = document.documentElement;
        if (theme === 'dark') root.classList.add('dark'); else root.classList.remove('dark');
        localStorage.setItem('theme', theme);
        themeBtn.innerHTML = root.classList.contains('dark') ? '<i class="fa-solid fa-sun" style="color: #FFD43B;"></i>' : '<i class="fa-solid fa-moon" style="color: #B197FC;"></i>';
      }
      function initTheme() {
        const saved = localStorage.getItem('theme');
        if (saved) applyTheme(saved);
        else {
          const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
          applyTheme(prefersDark ? 'dark' : 'light');
        }
      }
      themeBtn.addEventListener('click', () => {
        const nowDark = document.documentElement.classList.contains('dark');
        applyTheme(nowDark ? 'light' : 'dark');
      });
      // Mode switching
      const tabTimer = $('#tabTimer');
      const tabStopwatch = $('#tabStopwatch');
      const timerSection = $('#timerSection');
      const stopwatchSection = $('#stopwatchSection');
      function setMode(mode) {
        if (mode === 'timer') {
          timerSection.classList.remove('hidden');
          stopwatchSection.classList.add('hidden');
          tabTimer.classList.add('active-tab');
          tabStopwatch.classList.remove('active-tab');
          tabTimer.setAttribute('aria-selected', 'true');
          tabStopwatch.setAttribute('aria-selected', 'false');
        } else {
          stopwatchSection.classList.remove('hidden');
          timerSection.classList.add('hidden');
          tabStopwatch.classList.add('active-tab');
          tabTimer.classList.remove('active-tab');
          tabStopwatch.setAttribute('aria-selected', 'true');
          tabTimer.setAttribute('aria-selected', 'false');
        }
      }
      tabTimer.addEventListener('click', () => setMode('timer'));
      tabStopwatch.addEventListener('click', () => setMode('stopwatch'));
      // Fullscreen
      const fullscreenBtn = $('#fullscreenBtn');
      const navbar = $('#navbar');
      const fsHoverArea = $('#fsHoverArea');
      const peekNavBtn = $('#peekNavBtn');
      let fsHideTimer = null;
      function isFullscreen() { return !!document.fullscreenElement; }
      async function toggleFullscreen() {
        try {
          if (!isFullscreen()) await document.documentElement.requestFullscreen();
          else await document.exitFullscreen();
        } catch (e) { console.error('Fullscreen error', e); }
      }
      function setNavVisibility(visible) {
        if (visible) {
          navbar.style.transform = 'translateY(0)';
          navbar.style.opacity = '1';
          navbar.style.pointerEvents = 'auto';
        } else {
          navbar.style.transform = 'translateY(-100%)';
          navbar.style.opacity = '0';
          navbar.style.pointerEvents = 'none';
        }
      }
      function updateFSUI() {
        const fs = isFullscreen();
        fsHoverArea.classList.toggle('hidden', !fs);
        peekNavBtn.classList.toggle('hidden', !fs);
        if (fs) {
          setNavVisibility(false);
          document.addEventListener('mousemove', onFSActivity);
          document.addEventListener('keydown', onFSActivity);
        } else {
          setNavVisibility(true);
          document.removeEventListener('mousemove', onFSActivity);
          document.removeEventListener('keydown', onFSActivity);
        }
      }
      function onFSActivity() {
        if (!isFullscreen()) return;
        setNavVisibility(true);
        if (fsHideTimer) clearTimeout(fsHideTimer);
        fsHideTimer = setTimeout(() => setNavVisibility(false), 2000);
      }
      fullscreenBtn.addEventListener('click', toggleFullscreen);
      document.addEventListener('fullscreenchange', updateFSUI);
      fsHoverArea.addEventListener('mouseenter', () => setNavVisibility(true));
      fsHoverArea.addEventListener('mouseleave', () => { if (isFullscreen()) setNavVisibility(false); });
      peekNavBtn.addEventListener('click', () => {
        setNavVisibility(true);
        if (fsHideTimer) clearTimeout(fsHideTimer);
        fsHideTimer = setTimeout(() => setNavVisibility(false), 2500);
      });
      // Announcer overlay
      const announceOverlay = $('#announceOverlay');
      const announceText = $('#announceBubble > div:first-child');
      const announceSub = $('#announceBubble > div:last-child');
      const finalCountdownOverlay = $('#finalCountdownOverlay');
      const finalCountdownNumber = $('#finalCountdownNumber');
      let announceLock = false;
      let finalCountdownActive = false;
      function announce(main, sub = '', duration = 1100) {
        if (announceLock || finalCountdownActive) return;
        announceLock = true;
        announceText.textContent = main;
        announceSub.textContent = sub;
        announceOverlay.classList.remove('hidden');
        announceText.classList.remove('countdown-pop');
        void announceText.offsetWidth;
        announceText.classList.add('countdown-pop');
        document.body.classList.add('subtle-pulse');
        setTimeout(() => {
          announceOverlay.classList.add('hidden');
          document.body.classList.remove('subtle-pulse');
          announceLock = false;
        }, duration);
        if (navigator.vibrate) navigator.vibrate(35);
      }
      
      function showFinalCountdown(num) {
        if (num === 10) {
          finalCountdownActive = true;
          finalCountdownOverlay.classList.remove('hidden');
        }
        
        // Display number - 1, so 10 shows as 9, 1 shows as 0
        const displayNum = num - 1;
        finalCountdownNumber.textContent = displayNum === 0 ? "Waktu Habis!" : displayNum;
        finalCountdownNumber.classList.remove('final-countdown');
        void finalCountdownNumber.offsetWidth;
        finalCountdownNumber.classList.add('final-countdown');
        
        if (navigator.vibrate) {
          if (displayNum === 0) navigator.vibrate([100, 50, 100]);
          else navigator.vibrate(50);
        }
        
        if (displayNum === 0) { // Check displayNum instead of num
          // Throw confetti!
          throwConfetti();
          
          setTimeout(() => {
            finalCountdownOverlay.classList.add('hidden');
            finalCountdownActive = false;
          }, 2000);
        }
      }

      function throwConfetti() {
        const colors = ['#6366f1', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#3b82f6'];
        const confettiCount = 80;
        
        for (let i = 0; i < confettiCount; i++) {
          const confetti = document.createElement('div');
          confetti.style.position = 'fixed';
          confetti.style.width = Math.random() * 10 + 5 + 'px';
          confetti.style.height = Math.random() * 10 + 5 + 'px';
          confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
          confetti.style.left = Math.random() * 100 + '%';
          confetti.style.top = '-10px';
          confetti.style.opacity = '1';
          confetti.style.transform = `rotate(${Math.random() * 360}deg)`;
          confetti.style.zIndex = '70';
          confetti.style.pointerEvents = 'none';
          confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
          
          document.body.appendChild(confetti);
          
          const xDrift = (Math.random() - 0.5) * 200;
          const duration = Math.random() * 1000 + 2000;
          
          confetti.animate([
            { transform: `translate(0, 0) rotate(0deg)`, opacity: 1 },
            { transform: `translate(${xDrift}px, ${window.innerHeight + 20}px) rotate(${Math.random() * 720}deg)`, opacity: 0 }
          ], {
            duration: duration,
            easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
          });
          
          setTimeout(() => confetti.remove(), duration);
        }
      }
      // Timer logic
      const timerEditBtn = $('#timerEditBtn');
      const timerStartBtn = $('#timerStartBtn');
      const timerPauseBtn = $('#timerPauseBtn');
      const timerResumeBtn = $('#timerResumeBtn');
      const timerResetBtn = $('#timerResetBtn');
      const timerDisplayContainer = $('#timerDisplayContainer');
      const timerSegments = $$('.editable-time', timerDisplayContainer);
      const finishAudio = $('#finishAudio');
      let timerState = 'idle'; // 'idle' | 'running' | 'paused' | 'finished'
      let timerInitialMs = 5 * 60 * 1000;
      let timerEndAt = null;
      let timerRemainMs = timerInitialMs;
      let timerRAF = null;
      let timerThresholdsFired = new Set();
      const hmsToMs = (h, m, s) => (h * 3600 + m * 60 + s) * 1000;
      function getTimerHMS() {
        const h = parseInt(timerSegments.find(s => s.dataset.unit === 'hours').textContent || '0', 10) || 0;
        const m = parseInt(timerSegments.find(s => s.dataset.unit === 'minutes').textContent || '0', 10) || 0;
        const s = parseInt(timerSegments.find(s => s.dataset.unit === 'seconds').textContent || '0', 10) || 0;
        return { h, m, s };
      }
      function setTimerHMS(h, m, s) {
        timerSegments.find(sg => sg.dataset.unit === 'hours').textContent = pad2(Math.max(0, h));
        timerSegments.find(sg => sg.dataset.unit === 'minutes').textContent = pad2(Math.min(59, Math.max(0, m)));
        timerSegments.find(sg => sg.dataset.unit === 'seconds').textContent = pad2(Math.min(59, Math.max(0, s)));
        updateEditableAria();
      }
      function updateEditableAria() {
        const {h, m, s} = getTimerHMS();
        timerSegments.find(sg => sg.dataset.unit === 'hours').setAttribute('aria-valuenow', h);
        timerSegments.find(sg => sg.dataset.unit === 'minutes').setAttribute('aria-valuenow', m);
        timerSegments.find(sg => sg.dataset.unit === 'seconds').setAttribute('aria-valuenow', s);
      }
      function msToHMS(ms) {
        ms = Math.max(0, ms);
        const totalSec = Math.floor(ms / 1000);
        const h = Math.floor(totalSec / 3600);
        const m = Math.floor((totalSec % 3600) / 60);
        const s = totalSec % 60;
        return {h, m, s};
      }
      function updateTimerDisplay(ms) {
        const {h, m, s} = msToHMS(ms);
        setTimerHMS(h, m, s);
      }
      function setTimerState(newState) {
        timerState = newState;
        const show = (el, show) => el.classList.toggle('hidden', !show);
        show(timerStartBtn, newState === 'idle' || newState === 'finished' || newState === 'paused');
        show(timerPauseBtn, newState === 'running');
        show(timerResumeBtn, newState === 'paused');
        show(timerResetBtn, newState !== 'idle');
        const editable = newState !== 'running';
        for (const seg of timerSegments) {
          seg.classList.toggle('hover:bg-black/5', editable);
          seg.classList.toggle('dark:hover:bg-white/5', editable);
          seg.setAttribute('contenteditable', 'false');
        }
        timerEditBtn.disabled = !editable;
      }
      function startTimer() {
        const {h, m, s} = getTimerHMS();
        const total = hmsToMs(h, m, s);
        if (total <= 0) {
          announce('Set time', 'Please set a duration > 0', 900);
          timerDisplayContainer.classList.add('ring-pulse');
          setTimeout(() => timerDisplayContainer.classList.remove('ring-pulse'), 800);
          return;
        }
        timerInitialMs = total;
        timerRemainMs = total;
        timerEndAt = Date.now() + total;
        timerThresholdsFired.clear();
        lastSecondShown = -1;
        setTimerState('running');
        timerRAF = requestAnimationFrame(tickTimer);
      }
      function pauseTimer() {
        if (timerState !== 'running') return;
        timerRemainMs = Math.max(0, timerEndAt - Date.now());
        cancelAnimationFrame(timerRAF);
        setTimerState('paused');
      }
      function resumeTimer() {
        if (timerState !== 'paused') return;
        timerEndAt = Date.now() + timerRemainMs;
        lastSecondShown = -1;
        setTimerState('running');
        timerRAF = requestAnimationFrame(tickTimer);
      }
      function resetTimer() {
        cancelAnimationFrame(timerRAF);
        timerRemainMs = timerInitialMs;
        updateTimerDisplay(timerRemainMs);
        timerThresholdsFired.clear();
        lastSecondShown = -1;
        setTimerState('idle');
        
        // Re-enable tab navigation on reset
        timerSegments.forEach(seg => {
          seg.style.pointerEvents = '';
        });
      }
      function handleTimerFinish() {
        cancelAnimationFrame(timerRAF);
        setTimerState('finished');
        updateTimerDisplay(0);
        // Remove this line: showFinalCountdown(0);
        
        setTimeout(() => {
          finishAudio.currentTime = 0;
          finishAudio.play().catch(() => {});
        }, 400);
      }
      const thresholds = [
        30 * 60 * 1000, // 30 minutes left
        3 * 60 * 1000,
        2 * 60 * 1000,
        60 * 1000,
        30 * 1000,
      ];
      let lastSecondShown = -1;
      function maybeAnnounceThreshold(remain) {
        // Handle final 10 seconds with full screen countdown
        const currentSecond = Math.ceil(remain / 1000);
        
        if (currentSecond <= 10 && currentSecond >= 1 && currentSecond !== lastSecondShown) {
          lastSecondShown = currentSecond;
          showFinalCountdown(currentSecond);
          
          if (currentSecond === 10) {
            return true;
          }
        }
        
        // Handle other thresholds
        for (const th of thresholds) {
          if (remain <= th && !timerThresholdsFired.has(th) && timerInitialMs >= th) {
            timerThresholdsFired.add(th);
            let msg = '';
            if (th >= 60 * 1000) {
              const minutes = Math.round(th / 60000);
              msg = minutes === 30 ? '30 menit' :
                    minutes === 3 ? '3 menit' :
                    minutes === 2 ? '2 menit' :
                    minutes === 1 ? '1 menit' : `${minutes} min`;
            } else if (th === 30 * 1000) {
              msg = '30 detik';
            }
            timerDisplayContainer.classList.add('ring-pulse');
            setTimeout(() => timerDisplayContainer.classList.remove('ring-pulse'), 1000);
            announce(msg, '', 1100);
          }
        }
      }
      function tickTimer() {
        const now = Date.now();
        const remain = Math.max(0, timerEndAt - now);
        timerRemainMs = remain;
        updateTimerDisplay(remain);
        maybeAnnounceThreshold(remain);
        if (remain <= 0) { handleTimerFinish(); return; }
        timerRAF = requestAnimationFrame(tickTimer);
      }
      // Editable segments
      function enableInlineEdit(seg) {
        if (timerState === 'running') return;
        seg.setAttribute('contenteditable', 'true');
        seg.focus();
        document.execCommand && document.execCommand('selectAll', false, null);
        const unit = seg.dataset.unit;
        const max = unit === 'hours' ? Infinity : 59;
        function commit() {
          let val = parseInt(seg.textContent.replace(/[^\d]/g, ''), 10);
          if (Number.isNaN(val)) val = 0;
          val = Math.max(0, Math.min(max, val));
          seg.textContent = pad2(val);
          seg.setAttribute('contenteditable', 'false');
          updateEditableAria();
        }
        function onKey(e) {
          if (e.key === 'Enter') { e.preventDefault(); seg.blur(); }
          if (e.key === 'Escape') { e.preventDefault(); seg.setAttribute('contenteditable', 'false'); updateEditableAria(); seg.blur(); }
          if (e.key === 'ArrowUp') {
            e.preventDefault();
            let v = parseInt(seg.textContent || '0', 10) || 0;
            if (unit === 'hours') v = v + 1;
            else v = (v + 1) % 60;
            seg.textContent = pad2(v);
          }
          if (e.key === 'ArrowDown') {
            e.preventDefault();
            let v = parseInt(seg.textContent || '0', 10) || 0;
            if (unit === 'hours') v = Math.max(0, v - 1);
            else v = (v + 59) % 60;
            seg.textContent = pad2(v);
          }
        }
        function onBlur() {
          commit();
          seg.removeEventListener('keydown', onKey);
          seg.removeEventListener('blur', onBlur);
        }
        seg.addEventListener('keydown', onKey);
        seg.addEventListener('blur', onBlur);
      }
      $('#timerEditBtn').addEventListener('click', () => {
        if (timerState === 'running') return;
        $$('.editable-time').forEach(enableInlineEdit);
      });
      $$('.editable-time').forEach(seg => {
        seg.addEventListener('click', () => {
          if (seg.getAttribute('contenteditable') === 'true') return;
          enableInlineEdit(seg);
        });
      });

      function setupTabNavigation() {
        timerSegments.forEach((seg, index) => {
          seg.addEventListener('keydown', (e) => {
            // Only allow tab navigation when timer is not running
            if (timerState === 'running') return;
            
            if (e.key === 'Tab') {
              e.preventDefault();
              
              const segments = Array.from(timerSegments);
              let nextIndex;
              
              if (e.shiftKey) {
                // Shift + Tab: go to previous (left)
                nextIndex = index - 1;
                if (nextIndex < 0) nextIndex = segments.length - 1; // wrap to last (ss)
              } else {
                // Tab: go to next (right)
                nextIndex = index + 1;
                if (nextIndex >= segments.length) nextIndex = 0; // wrap to first (HH)
              }
              
              const nextSeg = segments[nextIndex];
              enableInlineEdit(nextSeg);
            }
          });
        });
      }

      // Presets
      $$('.chip[data-preset]').forEach(chip => {
        chip.addEventListener('click', () => {
          if (timerState === 'running') return;
          const addMs = parseInt(chip.dataset.preset, 10) || 0;
          const {h, m, s} = getTimerHMS();
          let total = hmsToMs(h, m, s) + addMs;
          total = Math.max(0, Math.min(total, 99 * 3600 * 1000));
          const hh = Math.floor(total / 3600000);
          const mm = Math.floor((total % 3600000) / 60000);
          const ss = Math.floor((total % 60000) / 1000);
          setTimerHMS(hh, mm, ss);
          timerInitialMs = total;
          timerRemainMs = total;
        });
      });
      // Timer buttons
      $('#timerStartBtn').addEventListener('click', startTimer);
      $('#timerPauseBtn').addEventListener('click', pauseTimer);
      $('#timerResumeBtn').addEventListener('click', resumeTimer);
      $('#timerResetBtn').addEventListener('click', resetTimer);
      setTimerHMS(0, 5, 0);
      setTimerState('idle');
      // Stopwatch logic
      const swDisplay = $('#swDisplay');
      const swStartBtn = $('#swStartBtn');
      const swPauseBtn = $('#swPauseBtn');
      const swResumeBtn = $('#swResumeBtn');
      const swResetBtn = $('#swResetBtn');
      const swLapBtn = $('#swLapBtn');
      const lapsList = $('#lapsList');
      const lapsEmpty = $('#lapsEmpty');
      let swState = 'stopped'; // 'running' | 'paused' | 'stopped'
      let swStartAt = 0;
      let swElapsedBefore = 0;
      let swRAF = null;
      let laps = [];
      let lastLapElapsed = 0;
      function formatHMSms(ms) {
        ms = Math.max(0, ms);
        const totalSec = Math.floor(ms / 1000);
        const h = Math.floor(totalSec / 3600);
        const m = Math.floor((totalSec % 3600) / 60);
        const s = totalSec % 60;
        const msPart = Math.floor(ms % 1000);
        return `${pad2(h)}:${pad2(m)}:${pad2(s)}.${pad3(msPart)}`;
      }
      function updateSWDisplay(ms) { swDisplay.textContent = formatHMSms(ms); }
      function setSWState(state) {
        swState = state;
        const S = (el, show) => el.classList.toggle('hidden', !show);
        S(swStartBtn, state === 'stopped');
        S(swPauseBtn, state === 'running');
        S(swResumeBtn, state === 'paused');
        S(swResetBtn, state !== 'stopped');
        S(swLapBtn, state === 'running');
      }
      function swStart() {
        swStartAt = performance.now();
        swElapsedBefore = 0;
        lastLapElapsed = 0;
        laps = [];
        renderLaps();
        setSWState('running');
        swRAF = requestAnimationFrame(swTick);
      }
      function swPause() {
        if (swState !== 'running') return;
        const now = performance.now();
        const elapsed = now - swStartAt + swElapsedBefore;
        swElapsedBefore = elapsed;
        cancelAnimationFrame(swRAF);
        setSWState('paused');
      }
      function swResume() {
        if (swState !== 'paused') return;
        swStartAt = performance.now();
        setSWState('running');
        swRAF = requestAnimationFrame(swTick);
      }
      function swReset() {
        cancelAnimationFrame(swRAF);
        swElapsedBefore = 0;
        updateSWDisplay(0);
        laps = [];
        renderLaps();
        setSWState('stopped');
      }
      function swLap() {
        const now = (swState === 'running')
          ? (performance.now() - swStartAt + swElapsedBefore)
          : swElapsedBefore;
        const lapDuration = now - lastLapElapsed;
        lastLapElapsed = now;
        laps.unshift({ total: now, lap: lapDuration, index: laps.length + 1 });
        renderLaps();
        swDisplay.classList.add('ring-pulse');
        setTimeout(() => swDisplay.classList.remove('ring-pulse'), 800);
      }
      function renderLaps() {
        lapsList.innerHTML = '';
        if (laps.length === 0) {
          lapsEmpty.classList.remove('hidden');
          return;
        }
        lapsEmpty.classList.add('hidden');
        for (const item of laps) {
          const row = document.createElement('div');
          row.className = 'py-2 flex items-center justify-between text-sm hover:bg-black/5 dark:hover:bg-white/5 px-2 rounded-md cursor-pointer';
          const left = document.createElement('div');
          left.className = 'font-medium opacity-80';
          left.textContent = `Lap ${item.index}`;
          const right = document.createElement('div');
          right.className = 'font-mono';
          right.innerHTML = `<span class="opacity-70 mr-3">${formatHMSms(item.total)}</span> <span class="chip">${formatHMSms(item.lap)}</span>`;
          row.append(left, right);
          row.addEventListener('click', async () => {
            try {
              await navigator.clipboard.writeText(`Lap ${item.index} — ${formatHMSms(item.lap)} (Total ${formatHMSms(item.total)})`);
              announce('Copied', `Lap ${item.index}`, 900);
            } catch {
              announce('Copy failed', '', 900);
            }
          });
          lapsList.appendChild(row);
        }
      }
      function swTick(now) {
        const elapsed = now - swStartAt + swElapsedBefore;
        updateSWDisplay(elapsed);
        swRAF = requestAnimationFrame(swTick);
      }
      swStartBtn.addEventListener('click', swStart);
      swPauseBtn.addEventListener('click', swPause);
      swResumeBtn.addEventListener('click', swResume);
      swResetBtn.addEventListener('click', swReset);
      swLapBtn.addEventListener('click', swLap);
      // Initialize
      initTheme();
      setMode('timer');
      updateSWDisplay(0);
      updateEditableAria();
      setupTabNavigation();

      // Keyboard shortcuts: Space start/pause; L lap; R reset
      document.addEventListener('keydown', (e) => {
        if (document.activeElement && document.activeElement.getAttribute('contenteditable') === 'true') return;
        
        // Escape key - exit fullscreen timer mode
        if (e.key === 'Escape' && isFullscreenTimerMode) {
          e.preventDefault();
          toggleFullscreenTimerMode();
          return;
        }
        
        // F key - toggle fullscreen timer mode (only on timer tab)
        if (e.key.toLowerCase() === 'f' && timerSection.classList.contains('hidden') === false) {
          e.preventDefault();
          toggleFullscreenTimerMode();
          return;
        }
        
        if (e.code === 'Space') {
          e.preventDefault();
          if (!document.fullscreenElement) {
            if (!stopwatchSection.classList.contains('hidden')) {
              if (swState === 'running') swPause(); else if (swState === 'paused') swResume(); else swStart();
            } else {
              if (timerState === 'running') pauseTimer();
              else if (timerState === 'paused') resumeTimer();
              else startTimer();
            }
          }
        }
        if (e.key.toLowerCase() === 'l' && swState === 'running') swLap();
        if (e.key.toLowerCase() === 'r') {
          if (!stopwatchSection.classList.contains('hidden')) {
            if (swState !== 'stopped') swReset();
          } else {
            if (timerState !== 'idle') resetTimer();
          }
        }
      });

      let isFullscreenTimerMode = false;

      function toggleFullscreenTimerMode() {
        if (stopwatchSection.classList.contains('hidden')) {
          isFullscreenTimerMode = !isFullscreenTimerMode;
          document.body.classList.toggle('fullscreen-timer-mode', isFullscreenTimerMode);
          
          if (isFullscreenTimerMode) {
            // Hide all interactive elements
            timerSegments.forEach(seg => {
              seg.style.pointerEvents = 'none';
              seg.setAttribute('contenteditable', 'false');
            });
          } else {
            // Restore interactivity
            timerSegments.forEach(seg => {
              seg.style.pointerEvents = '';
            });
          }
        }
      }

    </script>
  </body>
</html>
